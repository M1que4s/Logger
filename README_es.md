# Logger

Una pequeña y versátil librería para crear ficheros de registros con Lua que puedes integrar facilmente en tus proyectos.
Tan fácil como:

```lua
local Logger = require("Logger")
local log = Logger("MyScript", os.getenv("HOME"), true)
log("Librería para registros iniciada!", "info")
log("Este es un mensaje para depuración")

-- Algo de código por aquí...

local config = load_config() -- función de ejemplo...
-- Muy similar a la función assert()
log:expect(type(config) == "table", "la configuración de usuario no pudo ser cargada")

-- Más código aquí...
```

Y tendrás una salida como esta:

![Capture 1](capture_es.png)

Y un fichero en tu carpeta `$HOME` llamado `MyScript_DATE.log` (donde `DATE` es el resultado de `os.date("%Y-%m-%d")`) con un contenido como este:

```
11:43:55 [AUTOGENERATED BY LOGGER]
11:43:55 [MyScript INFO.] Test.lua@3: Librería de registros iniciada!
11:43:55 [MyScript DEBUG] Test.lua@4: Este es un mensaje para depuración
11:43:55 [MyScript ERROR] Test.lua@10: la configuración de usuario no pudo ser cargada

11:43:55 [SOMETHING WENT WRONG!]
```

### Documentación

Logger es una librería "Orientada a Objetos" y cuando es cargada con `require()`, retorna el objeto/clase "Logger". Esto es así porque quizás quieras tener varias instancias de Logger, pero usarlas para diferentes tipos de registros. Si no es así como deseas trabajar con Logger, no hay problema, puedes cagar Logger una vez y usarlo como quieras:

```lua
local log = require("Logger")("Script", nil, true)
log("Esto es un mensaje de información", "info")
```

Con eso, ya tienes una instancia de Logger disponible para usar.

#### Propiedades

Evidentemente, todas estas propiedades pueden ser modificadas (ya que Lua no es un lenguaje orientado a objetos), sin embargo, recomiendo seguir los flags de acceso y los tipos de datos indicados para asegurar el comportamiento correcto de Logger.

 * \[ _READ_ / _WRITE_ \] (__string__) `Path` La ruta en donde se guardan los registros (vease el método `new()`)
 * \[ _READ_ / _WRITE_ \] (__string__) `Namespace` El espacio de nombres que se muestra en la consola (vease el método `new()`)
 * \[ _READ_ / _WRITE_ \] (__boolean__) `Console` Habilita o deshabilita la impresión en consola (vease el método `new()`)
 * \[ _READ_ / _WRITE_ \] (__string__) `LogLvl` El nivel de registro por defecto (vease el método `setLogLvl()`)
 * \[ _READ_ \] (__string__) `Header` Plantilla de encabezado (vease el método `new()` y `header()`)
 * \[ _READ_ / _WRITE_ \] (__string__) `FileSuffix` Sufijo usado en el nombre de fichero de registro (vease el método `setFileSuffix()`).
 * \[ _READ_ \] (__table__) `Type` Contiene información sobre los tipos de logs, usado solo internamente.

READ: Lectura. Recomiendo no modificar

READ/WRITE: Lectura y escritura. Puede modificarse libremente, pero conservando el tipo de dato

#### Métodos

  * `new([name, dir, console, suffix, header, ...])`: Constructor. Igual que `Logger()`. Esta función es principalmente para un uso más cómodo de la librería y básicamente prepara algunos elementos para ser usados por la función `log()`. Argumentos (opcionales):
    * (__string__) `name` El nombre de tu aplicación/proyecto/script, entre otros. Básicamente un nombre con el que puedas identificar algo en particular, es útil si piensas usar varias instancias de Logger.
    * (__string__) `dir` Un directorio existente donde Logger guardará los ficheros de registro. Si no existe, tendrás un error.
    * (__boolean__) `console` Por defecto, Logger solo escribe ficheros de registro, pero si este argumento es `true`, entonces también escribirá registros en la terminal/consola.
    * (__string__) `suffix` Puedes cambiar el sufijo por defecto de los archivos, el cual es: `Year-Month-Day` en números. Este argumento _debería_ ser un string con un formato aceptado por `os.date()`.
    * (__string__) `header` Cuando esta función es llamada para crear una instancia de Logger, siempre se escribre una cabezera antes de todos los registros en el archivo, la cual es "AUTOGENERATED BY LOGGER". Con este argumento puedes cambiar ese texto.
    * (__any__) `...` Varargs utilizados con `string.format()` para el argumento `header`

  * `log(msg [, lvl, ...])`: La función principal que escribe registros. En una instancia de Logger puede ser llamada con `log()` en lugar de `log:log()`. Argumentos:
    * (__string__) `msg` El mensaje que desea registrar.
    * (__string [opcional]__) `lvl` El nivel de registro (ver la lista más abajo).
    * (__any [opcional]__) `...` Varargs usados con `string.format()` para colocar valores en `msg`.

  * `expect(exp, msg [, lvl, ...])`: El equivalente de `assert()`. Si el argumento `exp` es `false` o `nil` entonces se registra el mensaje `msg`. A excepción de `exp`, todos los demás argumentos funcionan como en `log()`:
    * (__any__) `exp` Una expresión de Lua.
    * (__string__) `msg` El mensaje que desea registrar.
    * (__string [opcional]__) `lvl` El nivel de registro (ver la tabla más abajo)
    * (__any [opcional]__) `...` Varargs usados con `string.format()` para colocar valores en `msg`.

  * `header(msg, ...)`: Escribe una cabezera que puede ser usada de diferentes formas, como separar registros o crear "puntos de quiebre", entre otros. Argumentos:
    * (__string__) `msg` El texto que desea registrar.
    * (__any__) `...` Varargs para `msg`.

  * `setLogLvl(lvl)`: Logger ahora maneja internamente un nivel de registro por defecto para que, en caso de no especificarse, ese valor sea usado en su lugar. Con esta función se puede cambiar dicho valor de forma segura.
  Argumentos:
    * (__string__) `lvl` El nuevo nivel de registro por defecto.

  * `setFileSuffix(fmt)`: Cambia el sufijo usado en los nombres de archivo de registro. Ten en cuenta que esto significa que se pueden generar varios archivos de registro y los registros generados por Logger se podrían escribir en diferentes ficheros. Argumentos:
    * (__string__) `fmt` El nuevo formato. Al igual que en el constructor de Logger, se espera que sea un texto soportado por `os.date()`.

La función `log()` y `expect()` aceptan los siguientes valores en el argumento `lvl` (refiriéndose al "nivel de importancia"):

  * `"other"` Cualquier cosa que no tiene una importancia relevante
  * `"trace"` Rastros internos de "algo" en el programa
  * `"debug"` Información para depurar (usado mayormente por desarrolladores)
  * `"info"`  Información que pueda ser útil para diferentes cosas
  * `"warn"`  Probablemente las cosas no van como deberían
  * `"error"` Hubo un problema
  * `"fatal"` Algo terriblemente malo sucedió

Estos valores siguen un nivel de 0 (`"other"`) al 6 (`"fatal"`).
Un valor mayor a 4 (`"warn"`) causa que Logger detenga la ejecución de Lua.